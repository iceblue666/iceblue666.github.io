[TOC]

# 前端问题汇总

## CSS问题

### 1. BFC

**块格式化上下文（Block Formatting Context，BFC）** 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

如何生成：

`float`不为`none`。

`overflow`不为`visible`。

`display`的值为`table-cell`、`table-caption`和`inline-block`

`position`的值不为`static`或`releative`中的任何一个。

`display: flow-root`无副作用生成BFC

应用：外部容器包含浮动元素高度,清除浮动

​			外边距

### 2. em和rem区别

​	em相对于父元素，rem相对于html根元素。

## JS问题

### 1. async和defer

```js
<script src="a.js"></script>
```

正常遇到script标签，会先停止解析document，请求js脚本，解析js脚本，继续解析document

```
<script src="d.js" defer></script>
<script src="e.js" defer></script>
```

**defer** 不管两个js，先下载，document解析完按顺序执行

```
<script src="b.js" async></script>
<script src="c.js" async></script>
```

**async** 不管两个js，ducument正常解析，一旦任何js下载好了，立刻执行

### 2. 闭包

通俗的讲就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。

**什么情况下会用到闭包？**

最常见的是函数封装的时候，再就是在使用定时器的时候，会经常用到

**闭包的用处有哪些？**

一个是它可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中

```
var num = new Array();
for(var i=0; i<4; i++){
    num[i] = f1(i);
}
function f1(n){
     function f2(){
         alert(n);
     }
     return f2;
}
num[2](); // 2
num[1](); // 1
num[0](); // 0
num[3](); // 3
```

### 3. 模块

**模块的作用**

可以把功能分成不同的文件，开放部分接口，变量有自己的作用域。

**模块原理**

```
let module = (function() {
  //模块列表集合
  const moduleLists = {};
  function define(name, modules, action) {
    modules.map((m, i) => {
      modules[i] = moduleLists[m];
    });
    //执行并保存模块
    moduleLists[name] = action.apply(null, modules);
  }

  return { define };
})();

//声明模块不依赖其它模块
module.define("hd", [], function() {
  return {
    show() {
      console.log("hd module show");
    }
  };
});

//声明模块时依赖其它模块
module.define("xj", ["hd"], function(hd) {
  hd.show();
});
```

> 模块自动采用严格模式，相当于defer
>
> 模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据。



### 4. call, bind, apply

**call**

```
fn.call(this,arg1,arg2...)
```

call的第一个变量是要指向的this的新object

接受的参数列表

**apply**

```
fn.apply(this,[arg1,arg2...])
```

apply的第一个变量是要指向的this的新object

接受的是参数数组（或者类数组对象）

**bind**

```
fn.bind(this,[arg1,arg2...])
```

apply的第一个变量是要指向的this的新object

接受的是参数数组（或者类数组对象）

但返回值是新的函数。

### 5. 实现call, apply, bind

```js
function add(c, d){
    return this.a+this.b+c+d;
}
const obj = { a: 1, b: 2 };
Function.prototype.myCall = function(context) {
    var content = context || window;
    content.fn = this;
    var args = [...arguments];
    args.shift();
    const result = context.fn(...args);
    return result;
}

console.log(add.call(obj, 6,6));
```

```js
function add(c, d) {
    return this.a + this.b + c + d;
}
const obj = {
    a: 1,
    b: 2
};
Function.prototype.myApply = function (context, arr) {
    var content = context || window;
    content.fn = this;
    return content.fn(...arr);
}

console.log(add.myApply(obj, [6, 6]));
```

```js
var obj = {
    NUM: 3
}
function add(x, y) {
    return this.NUM + x + y;
}

// var fn = add.bind(obj,3, 3);
// console.log(fn());
Function.prototype.myBind = function(context) {
    var context = context || window;
    var fn = this;
    console.log(arguments);
    var args = Array.prototype.slice.call(arguments, 1)
    return function(){
        return fn.apply(context, args);
    }
}

var fn = add.myBind(obj, 3, 3);
console.log(fn());
```

### 6. 0.1 + 0.2 === 0.3

答案是：不等，输出为false

因为浮点数和整数都是按照IEEE754 64位标准，1位标志位，11位阶码，52位尾数。

### 7. 柯里化

```js
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```

实际上是闭包的应用。

**用处**：可以固化参数。

### 8. arguments

arguments看上去是个数组，实际上是个对象，只是刚好第一个元素的key叫0，第二个元素的key叫1....

不过可以用Array.prototype.slice.call(arguments, 1)等方式

### 9. 变量提升

解析器会先解析代码，然后把声明的变量的声明提升到最前，这就叫做变量提升。

```js
console.log(web); // undefined
var web;
web = "fdsaf"
```

这一段按照顺序来说，应该是报错，但是由于变量提升，预解析过程中变量会提到前面，像如下代码

```
var web;
console.log(web); // undefined
web = "fdsaf"
```

**TDZ(暂时性死区)**

TDZ 又称暂时性死区，指变量在作用域内已经存在，但必须在`let/const`声明后才可以使用。

### 10. var, let, const

**作用域**

全局作用域、函数作用域、块级作用域

**全局作用域**

var直接变成window.变量

let是原来名字

**函数作用域**

var会变量提升

**块级作用域**

生成：{} while(){}

let定义变量仅能在块内使用

**全局变量**

不在函数内用var声明的变量(var v = 10)，在函数内直接隐式定义的变量(a = 3)

函数内var = 块级作用域let

var重复声明会选下面的，let重复声明报错

## 网络问题

### 1. URL输入后发生了什么

 1. **DNS域名解析**

    - 在浏览器DNS缓存中搜索
    - 在操作系统DNS缓存中搜索
    - 读取系统hosts文件，查找其中是否有对应的ip
    - 向本地配置的首选DNS服务器发起域名解析请求

 2. **建立TCP连接**

 3. **发起HTTP请求**

    请求方法：

    - GET:获取资源
    - POST:传输实体主体
    - HEAD:获取报文首部
    - PUT:传输文件
    - DELETE:删除文件
    - OPTIONS:询问支持的方法
    - TRACE:追踪路径
4. **接受响应结果**

状态码：
- 1**：信息性状态码
- 2**：成功状态码
    200：OK 请求正常处理
    204：No Content请求处理成功，但没有资源可返回
    206：Partial Content对资源的某一部分的请求
- 3**：重定向状态码
    301：Moved Permanently 永久重定向
    302：Found 临时性重定向
    304：Not Modified 缓存中读取
- 4**：客户端错误状态码
    400：Bad Request 请求报文中存在语法错误
    401：Unauthorized需要有通过Http认证的认证信息
    403：Forbidden访问被拒绝
    404：Not Found无法找到请求资源
- 5**：服务器错误状态码
    500：Internal Server Error 服务器端在执行时发生错误
    503：Service Unavailable 服务器处于超负载或者正在进行停机维护
5. **浏览器解析html**
	
6. **浏览器渲染**